#!/usr/bin/env bash
################################################################################
################################################################################
####### Sync or update repository visibilty ####################################
################################################################################
################################################################################

# LEGEND:
# This script is used by the gh command line to help sync or update the
# visibility of repositories. If no input file is provided, it will sync the
# visibility of all repositories. 
# If an input file is provided, it will update
# the visibility of all repositories in the input file.

#
# PREREQS:
# You need to have the following to run this script successfully:
# - GitHub Personal Access Token with a scope of "repos" and access to the organization(s) that will be updated.
# - Either the name of the organizations to be synced, or a file containing the names of the repositories to be updated
# - jq installed on the machine running the query
#
# NOTES:
# Input file should be in the format:
# Org_Name/Repo_Name1,public,false
# Org_Name/Repo_Name2,internal,false
# Org_Name/Repo_Name3,private,true
#
# It can handle multiple organizations and repositories.
# The last field in the input file is the isTemplate and is a boolean true or false.
# The script will still run if completly missing the isTemplate field.

################################################################################
#### Function PrintUsage #######################################################
PrintUsage()
{
  cat <<EOM
Usage: gh repo-visibility [options]

Options:
    -h, --help                    : Show script help
    -d, --debug                   : Enable Debug logging
    -i, --input                   : Set path to a file with a list of Org/Repo,visibility,template to update, one per line
    -dt, --destination-token      :  Set Personal Access Token with repo scope to destination Organization
    -st, --source-token           : Set Personal Access Token with repo scope to original Organization
    -p, --repo-page-size          : Set the pagination size for the initial repository GraphQL query - defaults to 20
                                    If a timeout occurs, reduce this value
    -so, --source-org             : Name of the source GitHub Organization to be analyzed
    -do, --destination-org        : Name of the destination GitHub Organization to be updated

Description:
repo-visibilty scans a source organization or input file for all repositories and gathers their visibilty.
  It then updates the visibilty of all repositories in the destination organization.

Example:
  gh repo-visibility --source-org OriginalOrg --destination-org MyNewOrg --source-token ABCDEFG1234567 --destination-token 1234567ABCDEFG

EOM
  exit 0
}
####################################
# Read in the parameters if passed #
####################################
PARAMS=""
while (( "$#" )); do
  case "$1" in
    -h|--help)
      PrintUsage;
      ;;
    -d|--debug)
      DEBUG=true
      shift
      ;;
    -dt|--destination-token)
      DESTINATION_TOKEN=$2
      shift 2
      ;;
    -st|--source-token)
      SOURCE_TOKEN=$2
      shift 2
      ;;
    -i|--input)
      INPUT_FILE_NAME=$2
      shift 2
      ;;
    -p|--repo-page-size)
      REPO_PAGE_SIZE=$2
      shift 2
      ;;
    -do|--destination-org)
      DESTINATION_ORG_NAME=$2
      shift 2
      ;;
    -so|--source-org)
      SOURCE_ORG_NAME=$2
      shift 2
      ;;
    --) # end argument parsing
      shift
      break
      ;;
    -*) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
    *) # preserve positional arguments
  PARAMS="$PARAMS $1"
  shift
  ;;
  esac
done

##################################################
# Set positional arguments in their proper place #
##################################################
eval set -- "$PARAMS"

############
# Defaults #
############
REPO_PAGE_SIZE="${REPO_PAGE_SIZE:-100}" # Default to 100 if not passed
SOURCE_END_CURSOR='null'                # Set to null, will be updated after call
DESTINATION_END_CURSOR='null'           # Set to null, will be updated after call
SLEEP='300'                             # Number of seconds to sleep if out of API calls
SLEEP_RETRY_COUNT='15'                  # Number of times to try to sleep before giving up
SLEEP_COUNTER='0'                       # Counter of how many times we have gone to sleep
GITHUB_API_URL='https://api.github.com' # Base URL for the GitHub API
LOG_DIR="$(pwd)"                        # Set to default log directory
EPOCH_TIME=$(date +%s)                  # Set to current epoch time
LOG_FILE="${LOG_DIR}/gh-repo-visibility-${EPOCH_TIME}.log" # Set to default log file name
LIST_INFO_FILE="${LOG_DIR}/gh-repo-visibility-${EPOCH_TIME}.list" # List of repo info

###########
# GLOBALS #
###########
SOURCE_REPO_ARRAY=()              # Array of source repo names
DESTINATION_REPO_ARRAY=()         # Array of destination repo names
UPDATE_REPO_ARRAY=()              # Array of repo names to update
REPOS_PARSED=0                    # Number of repos parsed from the input file
REPOS_UPDATED=0                   # Number of repos updated
REPOS_FAILED=0                    # Number of repos that failed to update
API_REMAINING_SOURCE=0            # Number of API calls remaining
API_REMAINING_DESTINATION=0       # Number of API calls remaining
API_LIMIT_REMAINING_DESTINATION=0 # Number of API calls remaining before we hit the limit
PARALLEL=0                        # If we can run in parallel
MAX_PARALLEL=6                    # Maximum number of parallel processes to run

################################################################################
############################ FUNCTIONS #########################################
################################################################################
################################################################################
################################################################################
#### Function DebugJQ ##########################################################
DebugJQ() {
  # If Debug is on, print it out...
  if [[ ${DEBUG} == true ]]; then
    echo "$1" | jq '.'
  fi
}
################################################################################
#### Function Debug ############################################################
Debug() {
  # If Debug is on, print it out...
  if [[ ${DEBUG} == true ]]; then
    echo "$1"
  fi
}
################################################################################
#### Function Header ###########################################################
Header() {
  echo ""
  echo "######################################################"
  echo "######################################################"
  echo "########## GitHub repo visibility updater ############"
  echo "######################################################"
  echo "######################################################"
  echo ""
  echo "Logs will be written to:[${LOG_FILE}]"
  echo "Repos information will be written to:[${LIST_INFO_FILE}]"
  echo ""

  # Debug info
  Debug "---- DEBUG ----"
  Debug "Source Token:[${SOURCE_TOKEN}]"
  Debug "Destination Token:[${DESTINATION_TOKEN}]"
  Debug "Source Organization:[${SOURCE_ORG_NAME}]"
  Debug "Destination Organization:[${DESTINATION_ORG_NAME}]"
  Debug "Repo Page Size:[${REPO_PAGE_SIZE}]"
  Debug "Input File:[${INPUT_FILE_NAME}]"
  Debug "---- DEBUG ----"
}
################################################################################
#### Function Footer ###########################################################
Footer() {
  #######################################
  # Basic footer information and totals #
  #######################################
  echo ""
  echo "######################################################"
  echo "The script has completed"
  echo "######################################################"
  echo "Repos Parsed:[${REPOS_PARSED}]"
  echo "Repos Updated:[${REPOS_UPDATED}]"
  echo "Repos Failed:[${REPOS_FAILED}]"
  echo "######################################################"
  echo ""
}
################################################################################
#### Function ValidateSem ######################################################
ValidateSem() {
  # Need to validate the machine has sem installed as we use it to do the
  #  actual work.
  if ! sem --version &>/dev/null
  then
    echo "Failed to find GNU sem in the path!"
    echo "https://www.gnu.org/software/parallel/"
    echo "This can be used to parallel the calls to the GitHub API."
    echo "without sem, we will have to do it serially."
  else
    PARALLEL=1
    # Create the file to run the parallel calls
    CreateParallelFile
  fi
}
################################################################################
#### Function ValidateJQ #######################################################
ValidateJQ() {
  # Need to validate the machine has jq installed as we use it to do the parsing
  # of all the json returns from GitHub

  if ! jq --version &>/dev/null
  then
    echo "Failed to find jq in the path!"
    echo "If this is a Mac, run command: brew install jq"
    echo "If this is Debian, run command: sudo apt install jq"
    echo "If this is Centos, run command: yum install jq"
    echo "Once installed, please run this script again."
    exit 1
  fi
}
################################################################################
#### Function CreateParallelFile ###############################################
CreateParallelFile() {
  # Create the file to run the parallel calls
  cat >"${LOG_DIR}/gh-repo-visibility-parallel.sh" <<EOL
#!/bin/bash
 
ORG_NAME="$1"
REPO_NAME="$2"
VISIBILITY="$3"
TEMPLATE="$4"
ARCHIVED="$5"
LOG_FILE="$6"
DESTINATION_TOKEN="$7"

echo "----------------------------------------------------"
echo "Updating visibility of:[${ORG_NAME}/${REPO_NAME}] to visibility:[${VISIBILITY}] and template:[${TEMPLATE}] and archived:[${ARCHIVED}]"
# Call the GitHub API to update the visibility of the repo
UPDATE_CMD=$(curl --fail -s -X PATCH \
  -H "Accept: application/vnd.github.v3+json" \
  -H "Authorization: token ${DESTINATION_TOKEN}" \
  -d "{\"visibility\": \"${VISIBILITY}\", \"isTemplate\": ${TEMPLATE}}, \"archived\": ${ARCHIVED}" \
  "https://api.github.com/repos/${ORG_NAME}/${REPO_NAME}" 2>&1)

#######################
# Load the error code #
#######################
ERROR_CODE=$?

##########################
# Check the shell return #
##########################
if [ ${ERROR_CODE} -eq 422 ] || [ ${ERROR_CODE} -eq 22 ]; then
  echo "Data was not updated, it was already up to date"
  echo "----------------------------------------------------"
  # Update the counters
  REPOS_UPDATED=$((REPOS_UPDATED+1))
  # Decrement the API limit remaining
  ((API_LIMIT_REMAINING_DESTINATION--))
  # Echo the information to the log file
  echo "Success: Repo:[${ORG_NAME}/${REPO_NAME}] was already up to date" >> "${LOG_FILE}"
elif [ ${ERROR_CODE} -eq 0 ]; then
  echo "Successfully updated data on GitHub!"
  echo "----------------------------------------------------"
  # Update the counters
  REPOS_UPDATED=$((REPOS_UPDATED+1))
  # Decrement the API limit remaining
  ((API_LIMIT_REMAINING_DESTINATION--))
  # Echo the information to the log file
  echo "Success: Repo:[${ORG_NAME}/${REPO_NAME}] was updated to visibility:[${VISIBILITY}] and template:[${TEMPLATE}] and archived:[${ARCHIVED}]" >> "${LOG_FILE}"
else
  echo "ERROR! Failed to update data from GitHub!"
  echo "ERROR_CODE:[${ERROR_CODE}]"
  echo "ERROR:[${UPDATE_CMD}]"
  # Update the counters
  REPOS_FAILED=$((REPOS_FAILED+1))
  # Decrement the API limit remaining
  ((API_LIMIT_REMAINING_DESTINATION--))
  # Echo the information to the log file
  echo "ERROR: Repo:[${ORG_NAME}/${REPO_NAME}] failed to update to visibility:[${VISIBILITY}] and template:[${TEMPLATE}] and archived:[${ARCHIVED}]" >> "${LOG_FILE}"
fi
EOL

  # Make the file executable
  chmod +x "${LOG_DIR}/gh-repo-visibility-parallel.sh"
}
################################################################################
#### Function CheckAPILimitDestination #########################################
CheckAPILimitDestination() {
  ##############################################################
  # Check what is remaining, and if 0, we need to sleep it off #
  ##############################################################
  API_REMAINING_REQUEST=$(curl -s -X GET \
    --url "${GITHUB_API_URL}/rate_limit" \
    -H "Authorization: Bearer ${DESTINATION_TOKEN}")

  Debug "DEBUG --- API REMAINING DATA BLOCK:"
  DebugJQ "${API_REMAINING_REQUEST}"

  API_REMAINING_MESSAGE=$(echo "${API_REMAINING_REQUEST}" \
    | jq -r '.message' 2>&1)

  if [[ "${API_REMAINING_MESSAGE}" != "Rate limiting is not enabled." ]]; then
    API_REMAINING_DESTINATION=$(echo "${API_REMAINING_REQUEST}" \
      | jq -r '.resources.graphql.remaining' 2>&1);
  else
    API_REMAINING_DESTINATION=9999999999
  fi

  #######################
  # Load the error code #
  #######################
  ERROR_CODE=$?

  ##############################
  # Check the shell for errors #
  ##############################
  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo  "ERROR! Failed to get valid response back from GitHub API!"
    echo "ERROR:[${API_REMAINING_DESTINATION}]"
    exit 1
  fi

  ##########################################
  # Check to see if we have API calls left #
  ##########################################
  if [[ "${API_REMAINING_DESTINATION}" -eq 0 ]]; then
    # Increment the sleep counter
    ((SLEEP_COUNTER++))
    # Warn the user
    echo "WARN! We have run out of GrahpQL calls and need to sleep!"
    echo "Sleeping for ${SLEEP} seconds before next check"
    # Check if we have slept enough
    if [ "${SLEEP_COUNTER}" -gt "${SLEEP_RETRY_COUNT}" ]; then
      # We have been doing this too long
      echo "ERROR! We have tried to wait for:[$SLEEP_RETRY_COUNT] attempts!"
      echo "ERROR! We only sleep for:[${SLEEP_COUNTER}] attempts!"
      echo "Bailing out!"
      exit 1
    else
      # Get some sleep...
      sleep "${SLEEP}"
    fi
  elif [[ "${API_REMAINING_DESTINATION}" == 9999999999 ]]; then
    echo "API rate limiting is not enabled."
    # Set API limit remaining to the value we have
    API_LIMIT_REMAINING_DESTINATION="${API_REMAINING_DESTINATION}"
  else
    echo "[${API_REMAINING_DESTINATION}] Destination API attempts remaining..."
    # Set API limit remaining to the value we have
    API_LIMIT_REMAINING_DESTINATION="${API_REMAINING_DESTINATION}"
  fi
}
################################################################################
#### Function CheckAPILimitSource ##############################################
CheckAPILimitSource() {
  ##############################################################
  # Check what is remaining, and if 0, we need to sleep it off #
  ##############################################################
  API_REMAINING_REQUEST=$(curl -s -X GET \
    --url "${GITHUB_API_URL}/rate_limit" \
    -H "Authorization: Bearer ${SOURCE_TOKEN}")

  Debug "DEBUG --- API REMAINING DATA BLOCK:"
  DebugJQ "${API_REMAINING_REQUEST}"

  API_REMAINING_MESSAGE=$(echo "${API_REMAINING_REQUEST}" \
    | jq -r '.message' 2>&1)

  if [[ "${API_REMAINING_MESSAGE}" != "Rate limiting is not enabled." ]]; then
    API_REMAINING_SOURCE=$(echo "${API_REMAINING_REQUEST}" \
      | jq -r '.resources.graphql.remaining' 2>&1);
  else
    API_REMAINING_SOURCE=9999999999
  fi

  #######################
  # Load the error code #
  #######################
  ERROR_CODE=$?

  ##############################
  # Check the shell for errors #
  ##############################
  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo  "ERROR! Failed to get valid response back from GitHub API!"
    echo "ERROR:[${API_REMAINING_SOURCE}]"
    exit 1
  fi

  ##########################################
  # Check to see if we have API calls left #
  ##########################################
  if [[ "${API_REMAINING_SOURCE}" -eq 0 ]]; then
    # Increment the sleep counter
    ((SLEEP_COUNTER++))
    # Warn the user
    echo "WARN! We have run out of GrahpQL calls and need to sleep!"
    echo "Sleeping for ${SLEEP} seconds before next check"
    # Check if we have slept enough
    if [ "${SLEEP_COUNTER}" -gt "${SLEEP_RETRY_COUNT}" ]; then
      # We have been doing this too long
      echo "ERROR! We have tried to wait for:[$SLEEP_RETRY_COUNT] attempts!"
      echo "ERROR! We only sleep for:[${SLEEP_COUNTER}] attempts!"
      echo "Bailing out!"
      exit 1
    else
      # Get some sleep...
      sleep "${SLEEP}"
    fi
  elif [[ "${API_REMAINING_SOURCE}" == 9999999999 ]]; then
    echo "API rate limiting is not enabled."
  else
    echo "[${API_REMAINING_SOURCE}] Source API attempts remaining..."
  fi
}
################################################################################
#### Function UpdateRepoVisibility #############################################
UpdateRepoVisibility() {
  # Pull in vars from the function call
  ORG_NAME="$1"
  REPO_NAME="$2"
  VISIBILITY="$3"
  TEMPLATE="$4"
  ARCHIVED="$5"

  echo "----------------------------------------------------"
  echo "Updating visibility of:[${ORG_NAME}/${REPO_NAME}] to visibility:[${VISIBILITY}] and template:[${TEMPLATE}] and archived:[${ARCHIVED}]"
  # Call the GitHub API to update the visibility of the repo
  UPDATE_CMD=$(curl --fail -s -X PATCH \
    -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token ${DESTINATION_TOKEN}" \
    -d "{\"visibility\": \"${VISIBILITY}\", \"isTemplate\": ${TEMPLATE}}, \"archived\": ${ARCHIVED}" \
    "https://api.github.com/repos/${ORG_NAME}/${REPO_NAME}" 2>&1)
  
  #######################
  # Load the error code #
  #######################
  ERROR_CODE=$?

  ##########################
  # Check the shell return #
  ##########################
  if [ ${ERROR_CODE} -eq 422 ] || [ ${ERROR_CODE} -eq 22 ]; then
    echo "Data was not updated, it was already up to date"
    echo "----------------------------------------------------"
    # Update the counters
    REPOS_UPDATED=$((REPOS_UPDATED+1))
    # Decrement the API limit remaining
    ((API_LIMIT_REMAINING_DESTINATION--))
    # Echo the information to the log file
    echo "Success: Repo:[${ORG_NAME}/${REPO_NAME}] was already up to date" >> "${LOG_FILE}"
  elif [ ${ERROR_CODE} -eq 0 ]; then
    echo "Successfully updated data on GitHub!"
    echo "----------------------------------------------------"
    # Update the counters
    REPOS_UPDATED=$((REPOS_UPDATED+1))
    # Decrement the API limit remaining
    ((API_LIMIT_REMAINING_DESTINATION--))
    # Echo the information to the log file
    echo "Success: Repo:[${ORG_NAME}/${REPO_NAME}] was updated to visibility:[${VISIBILITY}] and template:[${TEMPLATE}] and archived:[${ARCHIVED}]" >> "${LOG_FILE}"
  else
    echo "ERROR! Failed to update data from GitHub!"
    echo "ERROR_CODE:[${ERROR_CODE}]"
    echo "ERROR:[${UPDATE_CMD}]"
    # Update the counters
    REPOS_FAILED=$((REPOS_FAILED+1))
    # Decrement the API limit remaining
    ((API_LIMIT_REMAINING_DESTINATION--))
    # Echo the information to the log file
    echo "ERROR: Repo:[${ORG_NAME}/${REPO_NAME}] failed to update to visibility:[${VISIBILITY}] and template:[${TEMPLATE}] and archived:[${ARCHIVED}]" >> "${LOG_FILE}"
  fi
}
################################################################################
#### Function GetAllSourceRepos ################################################
GetAllSourceRepos() {
  echo "Getting all source repos for:[${SOURCE_ORG_NAME}]"
  Debug "SOURCE_END_CURSOR:[${SOURCE_END_CURSOR}]"

  # Need to quote the string if its not null
  SOURCE_END_CURSOR_STRING="${SOURCE_END_CURSOR}"
  if [[ "${SOURCE_END_CURSOR}" != "null" ]]; then
    SOURCE_END_CURSOR_STRING='\"'
    SOURCE_END_CURSOR_STRING+="${SOURCE_END_CURSOR}"
    SOURCE_END_CURSOR_STRING+='\"'
  fi
  # Need to quote the string
  SOURCE_ORG_NAME_STRING='\"'
  SOURCE_ORG_NAME_STRING+="${SOURCE_ORG_NAME}"
  SOURCE_ORG_NAME_STRING+='\"'

  # Get the data block from the GitHub API
  DATA_BLOCK=$(curl --fail -s -X POST \
    --url https://api.github.com/graphql \
    -H 'Accept: application/vnd.github.starfire-preview+json' \
    -H "Authorization: Bearer ${SOURCE_TOKEN}" \
    -H 'Content-Type: application/json' \
    -d "{\"query\":\"query {organization(login: ${SOURCE_ORG_NAME_STRING}) {repositories(first: ${REPO_PAGE_SIZE}, after: ${SOURCE_END_CURSOR_STRING}) {nodes {nameWithOwner visibility isTemplate isArchived}totalCount pageInfo {hasNextPage endCursor}}}}\"}" 2>&1)

  #######################
  # Load the error code #
  #######################
  ERROR_CODE=$?

  ##########################
  # Check the shell return #
  ##########################
  if [ $ERROR_CODE -ne 0 ]; then
    echo "ERROR! Failed to gather data from GitHub!"
    exit 1
  fi

  # Get the next page and end cursor
  NEXT_PAGE=$(echo "$DATA_BLOCK" | jq .[] | jq -r '.organization.repositories.pageInfo.hasNextPage')
  SOURCE_END_CURSOR=$(echo "$DATA_BLOCK" | jq .[] | jq -r '.organization.repositories.pageInfo.endCursor')

  # Debug info
  Debug "DATA_BLOCK:[${DATA_BLOCK}]"
  Debug "NEXT_PAGE:[${NEXT_PAGE}]"
  Debug "SOURCE_END_CURSOR:[${SOURCE_END_CURSOR}]"

  #############################################
  # Check the API limit remaining for GraphQL #
  #############################################
  CheckAPILimitSource

  #############################################
  # Parse all the repo data out of data block #
  #############################################
  ParseSourceRepoData "$DATA_BLOCK"

  ########################################
  # See if we need to loop for more data #
  ########################################
  if [ "$NEXT_PAGE" == "false" ]; then
    # We have all the data, we can move on
    echo "Gathered all data from source GitHub Organization"
    echo "----------------------------------------------------"
  elif [ "$NEXT_PAGE" == "true" ]; then
    # We need to loop through GitHub to get all repos
    echo "More pages of repos... Looping through data with new cursor:[$SOURCE_END_CURSOR]"
    ######################################
    # Call GetData again with new cursor #
    ######################################
    GetAllSourceRepos
  else
    # Failing to get this value means we didnt get a good response back from GitHub
    # And it could be bad input from user, not enough access, or a bad token
    # Fail out and have user validate the info
    echo ""
    echo "######################################################"
    echo "ERROR! Failed response back from GitHub!"
    echo "Please validate your PAT, Organization, and access levels!"
    echo "######################################################"
    exit 1
  fi
}
################################################################################
#### Function ParseSourceRepoData ##############################################
ParseSourceRepoData() {
  # Pull in the repos data block
  PARSE_DATA=$1
  # Convert the format to JSON
  _jq() {
    echo -n "${PARSE_DATA}" | base64 --decode | jq -r "${1}"
  }

  REPOS=$(echo "${PARSE_DATA}" | jq -r '.data.organization.repositories.nodes')
  for REPO_DATA in $(echo -n "${REPOS}" | jq -r '.[] | @base64'); do
    _jq() {
    echo -n "${REPO_DATA}" | base64 --decode | jq -r "${1}"
    }
    # Build out the vars for the function
    REPO_NAME=$(_jq '.nameWithOwner' | tr '[:upper:]' '[:lower:]')
    VISIBILITY=$(_jq '.visibility' | tr '[:upper:]' '[:lower:]')
    TEMPLATE=$(_jq '.isTemplate' | tr '[:upper:]' '[:lower:]')
    ARCHIVED=$(_jq '.isArchived' | tr '[:upper:]' '[:lower:]')
    # Debug info
    Debug "Repo Name:[${REPO_NAME}]"
    Debug "Visibility:[${VISIBILITY}]"
    Debug "Template:[${TEMPLATE}]"
    Debug "Archived:[${ARCHIVED}]"
    # Push the vars to the SOURCE_REPO_ARRAY
    SOURCE_REPO_ARRAY+=("${REPO_NAME}|${VISIBILITY}|${TEMPLATE}|${ARCHIVED}")
    # Update the counters
    REPOS_PARSED=$((REPOS_PARSED+1))
  done
}
################################################################################
#### Function GetAllDestinationRepos ###########################################
GetAllDestinationRepos() {
  echo "Getting all destination repos for:[${DESTINATION_ORG_NAME}]"
  Debug "DESTINATION_END_CURSOR:[${DESTINATION_END_CURSOR}]"

  # Need to quote the string if its not null
  DESTINATION_END_CURSOR_STRING="${DESTINATION_END_CURSOR}"
  if [[ "${DESTINATION_END_CURSOR}" != "null" ]]; then
    DESTINATION_END_CURSOR_STRING='\"'
    DESTINATION_END_CURSOR_STRING+="${DESTINATION_END_CURSOR}"
    DESTINATION_END_CURSOR_STRING+='\"'
  fi
  # Need to quote the string
  DESTINATION_ORG_NAME_STRING='\"'
  DESTINATION_ORG_NAME_STRING+="${DESTINATION_ORG_NAME}"
  DESTINATION_ORG_NAME_STRING+='\"'

  # Get the data block from the GitHub API
  DATA_BLOCK=$(curl --fail -s -X POST \
    --url https://api.github.com/graphql \
    -H 'Accept: application/vnd.github.starfire-preview+json' \
    -H "Authorization: Bearer ${DESTINATION_TOKEN}" \
    -H 'Content-Type: application/json' \
    -d "{\"query\":\"query {organization(login: ${DESTINATION_ORG_NAME_STRING}) {repositories(first: ${REPO_PAGE_SIZE}, after: ${DESTINATION_END_CURSOR_STRING}) {nodes {nameWithOwner visibility isTemplate isArchived}totalCount pageInfo {hasNextPage endCursor}}}}\"}" 2>&1)

  #######################
  # Load the error code #
  #######################
  ERROR_CODE=$?

  ##########################
  # Check the shell return #
  ##########################
  if [ $ERROR_CODE -ne 0 ]; then
    echo "ERROR! Failed to gather data from GitHub!"
    exit 1
  fi

  # Get the next page and end cursor
  NEXT_PAGE=$(echo "$DATA_BLOCK" | jq .[] | jq -r '.organization.repositories.pageInfo.hasNextPage')
  DESTINATION_END_CURSOR=$(echo "$DATA_BLOCK" | jq .[] | jq -r '.organization.repositories.pageInfo.endCursor')

  # Debug info
  Debug "DATA_BLOCK:[${DATA_BLOCK}]"
  Debug "NEXT_PAGE:[${NEXT_PAGE}]"
  Debug "DESTINATION_END_CURSOR:[${DESTINATION_END_CURSOR}]"

  #############################################
  # Check the API limit remaining for GraphQL #
  #############################################
  CheckAPILimitDestination

  #############################################
  # Parse all the repo data out of data block #
  #############################################
  ParseDestinationRepoData "$DATA_BLOCK"

  ########################################
  # See if we need to loop for more data #
  ########################################
  if [ "$NEXT_PAGE" == "false" ]; then
    # We have all the data, we can move on
    echo "Gathered all data from destination GitHub Organization"
    echo "----------------------------------------------------"
  elif [ "$NEXT_PAGE" == "true" ]; then
    # We need to loop through GitHub to get all repos
    echo "More pages of repos... Looping through data with new cursor:[$DESTINATION_END_CURSOR]"
    ######################################
    # Call GetData again with new cursor #
    ######################################
    GetAllDestinationRepos
  else
    # Failing to get this value means we didnt get a good response back from GitHub
    # And it could be bad input from user, not enough access, or a bad token
    # Fail out and have user validate the info
    echo ""
    echo "######################################################"
    echo "ERROR! Failed response back from GitHub!"
    echo "Please validate your PAT, Organization, and access levels!"
    echo "######################################################"
    exit 1
  fi
}
################################################################################
#### Function ParseDestinationRepoData #########################################
ParseDestinationRepoData() {
  # Pull in the repos data block
  PARSE_DATA=$1
  # Convert the format to JSON
  _jq() {
    echo -n "${PARSE_DATA}" | base64 --decode | jq -r "${1}"
  }

  REPOS=$(echo "${PARSE_DATA}" | jq -r '.data.organization.repositories.nodes')
  for REPO_DATA in $(echo -n "${REPOS}" | jq -r '.[] | @base64'); do
    _jq() {
    echo -n "${REPO_DATA}" | base64 --decode | jq -r "${1}"
    }
    # Build out the vars for the function
    REPO_NAME=$(_jq '.nameWithOwner' | tr '[:upper:]' '[:lower:]')
    VISIBILITY=$(_jq '.visibility' | tr '[:upper:]' '[:lower:]')
    TEMPLATE=$(_jq '.isTemplate' | tr '[:upper:]' '[:lower:]')
    ARCHIVED=$(_jq '.isArchived' | tr '[:upper:]' '[:lower:]')
    # Debug info
    Debug "Repo Name:[${REPO_NAME}]"
    Debug "Visibility:[${VISIBILITY}]"
    Debug "Template:[${TEMPLATE}]"
    Debug "Archived:[${ARCHIVED}]"
    # Push the vars to the DESTINATION_REPO_ARRAY
    DESTINATION_REPO_ARRAY+=("${REPO_NAME}|${VISIBILITY}|${TEMPLATE}|${ARCHIVED}")
     # Update the counters
    REPOS_PARSED=$((REPOS_PARSED+1))
  done
}
################################################################################
#### Function ValidateArgs #####################################################
ValidateArgs() {
  # Check if user has provided the required arguments
  echo "----------------------------------------------------"
  echo "Validating user input..."

  # Check if user has passed input file
  if [ -n "${INPUT_FILE_NAME}" ] || [ "${#INPUT_FILE_NAME}" -lt 1 ] && [ -z "${DESTINATION_TOKEN}" ]; then
    # user did not pass destination token, fail out
    echo "ERROR! You must provide a destination token to update the Destination Organization!"
    exit 1
  fi

  # Check we have all other vars if no input file
  if [ -z "${INPUT_FILE_NAME}" ]; then
    # Make lower case to prevent weird issues
    DESTINATION_ORG_NAME=$(echo "${DESTINATION_ORG_NAME}" | tr '[:upper:]' '[:lower:]')
    SOURCE_ORG_NAME=$(echo "${SOURCE_ORG_NAME}" | tr '[:upper:]' '[:lower:]')
    # We need both source and org vars
    if [ -z "${SOURCE_ORG_NAME}" ] || [ -z "${SOURCE_TOKEN}" ] || [ -z "${DESTINATION_ORG_NAME}" ] || [ -z "${DESTINATION_TOKEN}" ]; then
      echo "ERROR! You must provide [--destination-token] [--source-token] [--destination-org] [--source-org] to query and update!"
      exit 1
    fi
  fi
}
################################################################################
#### Function GenerateUpdateList ###############################################
GenerateUpdateList() {
  echo "----------------------------------------------------"
  echo "Parsing all data and generating update list..."
  # We now have all the data we need to generate the update list
  # SOURCE_REPO_ARRAY=()      # Array of source repo names
  # DESTINATION_REPO_ARRAY=() # Array of destination repo names
  # UPDATE_REPO_ARRAY=()      # Array of repo names to update
  #
  # String format per item is:
  # <org name>/<repo name>|<visibility>|<template>

  # Loop through the destination repos and see if we have a match in the source repos
  for DESTINATION_OBJECT in "${DESTINATION_REPO_ARRAY[@]}"; do
    # Split the repo name and visibility
    DESTINATION_REPO_STRING=$(echo "${DESTINATION_OBJECT}" | cut -d'|' -f1)
    DESTINATION_ORG=$(echo "${DESTINATION_REPO_STRING}" | cut -d'/' -f1)
    DESTINATION_REPO=$(echo "${DESTINATION_REPO_STRING}" | cut -d'/' -f2)
    # Debug Info
    Debug "DESTINATION_REPO_STRING:[${DESTINATION_REPO_STRING}]"
    Debug "DESTINATION_ORG:[${DESTINATION_ORG}]"
    Debug "DESTINATION_REPO:[${DESTINATION_REPO}]"
    # Loop through the source repos and see if we have a match
    for SOURCE_OBJECT in "${SOURCE_REPO_ARRAY[@]}"; do
      # Split the repo name and visibility
      SOURCE_REPO_STRING=$(echo "${SOURCE_OBJECT}" | cut -d'|' -f1)
      SOURCE_ORG=$(echo "${SOURCE_REPO_STRING}" | cut -d'/' -f1)
      SOURCE_REPO=$(echo "${SOURCE_REPO_STRING}" | cut -d'/' -f2)
      SOURCE_REPO_VISIBILITY=$(echo "${SOURCE_OBJECT}" | cut -d'|' -f2)
      SOURCE_REPO_TEMPLATE=$(echo "${SOURCE_OBJECT}" | cut -d'|' -f3)
      SOURCE_REPO_ARCHIVED=$(echo "${SOURCE_OBJECT}" | cut -d'|' -f4)
      # Debug Info
      Debug "SOURCE_OBJECT:[${SOURCE_OBJECT}]"
      Debug "SOURCE_REPO_STRING:[${SOURCE_REPO_STRING}]"
      Debug "SOURCE_ORG:[${SOURCE_ORG}]"
      Debug "SOURCE_REPO:[${SOURCE_REPO}]"
      Debug "SOURCE_REPO_VISIBILITY:[${SOURCE_REPO_VISIBILITY}]"
      Debug "SOURCE_REPO_TEMPLATE:[${SOURCE_REPO_TEMPLATE}]"
      Debug "SOURCE_REPO_ARCHIVED:[${SOURCE_REPO_ARCHIVED}]"
      # Check if the repo names match
      if [ "${SOURCE_REPO}" == "${DESTINATION_REPO}" ]; then
        # We have a match, update the UPDATE_REPO_ARRAY with the SOURCE_REPO_VISIBILITY and SOURCE_REPO_TEMPLATE
        UPDATE_REPO_ARRAY+=("${DESTINATION_ORG}/${DESTINATION_REPO}|${SOURCE_REPO_VISIBILITY}|${SOURCE_REPO_TEMPLATE}|${SOURCE_REPO_ARCHIVED}")
        echo "Adding:[${DESTINATION_ORG}/${DESTINATION_REPO}|${SOURCE_REPO_VISIBILITY}|${SOURCE_REPO_TEMPLATE}|${SOURCE_REPO_ARCHIVED}] to update array"
      fi
    done
  done

  # Debug info
  Debug "---- DEBUG ----"
  Debug "UPDATE_REPO_ARRAY:"
  for LINE in  "${UPDATE_REPO_ARRAY[@]}"; do
    Debug "${LINE}"
  done

  # Add all the repos to the list file for easier parsing
  echo "Repos to update:" >> "${LIST_INFO_FILE}"
  for LINE in "${UPDATE_REPO_ARRAY[@]}"; do
    echo "${LINE}" >> "${LIST_INFO_FILE}"
  done
}
################################################################################
#### Function ParseInputFile ###################################################
ParseInputFile() {
  # Find how many lines in the input file
  LINES=$(wc -l < "${INPUT_FILE_NAME}")
  # Debug info
  Debug "LINES in input file:[${LINES}]"
  # Check api limit
  CheckAPILimitDestination
  # Check if we have api limit higher than lines in file
  if [ "${LINES}" -gt "${API_LIMIT_REMAINING_DESTINATION}" ]; then
    # We have more lines than the api limit, fail out
    echo "ERROR! You have provided a file with more lines than the API limit of:[${API_LIMIT_REMAINING_DESTINATION}]!"
    echo "Please reduce the number of lines in the file, increase the API limit, or wait for api limit to reset!"
    exit 1
  fi

  # Read in the input file and parse the lines
  while read -r line; do
    #############################################
    # Split the line into the org and repo name #
    #############################################
    DESTINATION_ORG_NAME=$(echo "${line}" | cut -d'/' -f1 | tr '[:upper:]' '[:lower:]')
    DESTINATION_REPO_NAME=$(echo "${line}" | cut -d'/' -f2 | cut -d',' -f1| tr '[:upper:]' '[:lower:]')
    VISIBILITY=$(echo "${line}" | cut -d',' -f2 | tr '[:upper:]' '[:lower:]')
    TEMPLATE=$(echo "${line}" | cut -d',' -f3 | tr '[:upper:]' '[:lower:]')
    ARCHIVED=$(echo "${line}" | cut -d',' -f4 | tr '[:upper:]' '[:lower:]')
    # Check if we got template
    if [ -z "${TEMPLATE}" ] || [ "${#TEMPLATE}" -lt 1 ]; then
      TEMPLATE="false"
    fi
    # Check if we got archived
    if [ -z "${ARCHIVED}" ] || [ "${#ARCHIVED}" -lt 1 ]; then
      ARCHIVED="false"
    fi

    # Debug info
    Debug "---- DEBUG ----"
    Debug "DESTINATION_ORG_NAME:[${DESTINATION_ORG_NAME}]"
    Debug "DESTINATION_REPO_NAME:[${DESTINATION_REPO_NAME}]"
    Debug "VISIBILITY:[${VISIBILITY}]"
    Debug "TEMPLATE:[${TEMPLATE}]"
    Debug "ARCHIVED:[${ARCHIVED}]"
    Debug "---- DEBUG ----"
    
    # Check if parallel is enabled
    if [ "${PARALLEL}" -eq 1 ]; then
      sem -j${MAX_PARALLEL} "./${LOG_DIR}/gh-repo-visibility-parallel.sh" "${DESTINATION_ORG_NAME}" "${DESTINATION_REPO_NAME}" "${VISIBILITY}" "${TEMPLATE}" "${ARCHIVED}" "${LOG_FILE}" "${DESTINATION_TOKEN}"
    else
      #####################################
      # Update the visibility of the repo #
      #####################################
      UpdateRepoVisibility "${DESTINATION_ORG_NAME}" "${DESTINATION_REPO_NAME}" "${VISIBILITY}" "${TEMPLATE}" "${ARCHIVED}"
    fi
  done < "${INPUT_FILE_NAME}"

  # Wait for all the jobs to finish
  if [ "${PARALLEL}" -eq 1 ]; then
    # Wait for all the jobs to finish
    sem --wait
  fi
}
################################################################################
#### Function ParseUpdateArray #################################################
ParseUpdateArray() {
  # Check api limit
  CheckAPILimitDestination
  # Loop through the list of repos and update the visibility
  for OBJECT in "${UPDATE_REPO_ARRAY[@]}"; do
    # Check api limit remainging
    if [ "${API_LIMIT_REMAINING_DESTINATION}" -lt 1 ]; then
      # Check api limit
      CheckAPILimitDestination
    fi
    # Get the vars from the string
    ORG_REPO=$(echo "${OBJECT}" | cut -d'|' -f1)
    ORG=$(echo "${ORG_REPO}" | cut -d'/' -f1)
    REPO=$(echo "${ORG_REPO}" | cut -d'/' -f2)
    VISIBILITY=$(echo "${OBJECT}" | cut -d'|' -f2)
    TEMPLATE=$(echo "${OBJECT}" | cut -d'|' -f3)
    ARCHIVED=$(echo "${OBJECT}" | cut -d'|' -f4)
    # Debug info
    Debug "---- DEBUG ----"
    Debug "OBJECT:[${OBJECT}]"
    Debug "ORG_REPO:[${ORG_REPO}]"
    Debug "ORG:[${ORG}]"
    Debug "REPO:[${REPO}]"
    Debug "VISIBILITY:[${VISIBILITY}]"
    Debug "TEMPLATE:[${TEMPLATE}]"
    Debug "ARCHIVED:[${ARCHIVED}]"
    Debug "---- DEBUG ----"
    # Check if parallel is enabled
    if [ "${PARALLEL}" -eq 1 ]; then
      sem -j${MAX_PARALLEL} "./${LOG_DIR}/gh-repo-visibility-parallel.sh" "${DESTINATION_ORG_NAME}" "${DESTINATION_REPO_NAME}" "${VISIBILITY}" "${TEMPLATE}" "${ARCHIVED}" "${LOG_FILE}" "${DESTINATION_TOKEN}"
    else
      #####################################
      # Update the visibility of the repo #
      #####################################
      UpdateRepoVisibility "${DESTINATION_ORG_NAME}" "${DESTINATION_REPO_NAME}" "${VISIBILITY}" "${TEMPLATE}" "${ARCHIVED}"
    fi
    # Decrement the API limit remaining
    API_LIMIT_REMAINING_DESTINATION=$((API_LIMIT_REMAINING_DESTINATION-1))
  done

  # Wait for all the jobs to finish
  if [ "${PARALLEL}" -eq 1 ]; then
    # Wait for all the jobs to finish
    sem --wait
  fi
}
################################################################################
############################## MAIN ############################################
################################################################################

##########
# Header #
##########
Header

#####################################
# Validate we have enough arguments #
#####################################
ValidateArgs

#########################
# Validate JQ installed #
#########################
ValidateJQ

#############################################
# Validate if sem is installed for parallel #
#############################################
ValidateSem

#####################################
# Check if were using an input file #
#####################################
if [[ -n "${INPUT_FILE_NAME}" ]]; then
  ########################
  # Parse the input file #
  ########################
  ParseInputFile
else
  ####################################################################
  # Get the list of all repos in the source org and their visibility #
  ####################################################################
  GetAllSourceRepos
  #########################################################################
  # Get the list of all repos in the destination org and their visibility #
  #########################################################################
  GetAllDestinationRepos
  ###############################################################
  # Loop through the repos and generate list of repos to update #
  ###############################################################
  GenerateUpdateList
  ################################################################
  # Loop through the repos and update the visibility of the repo #
  ################################################################
  ParseUpdateArray
fi

##########
# Footer #
##########
Footer